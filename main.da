import sys
import random
import time
import orig3
import preemption3
codePaths=[preemption3,orig3]

class Driver(process):
    def setup(p,a,l,n,r,d,w,tp,tl):
        self.results={}



    def runPerformanceTests():
        acceptors={}
        proposers={}
        learners={}
        for codePath in codePaths:
            c=str(codePath.__name__)
            results[c]={}
            #output("====================================================================================")
            #output("=============================",str(codePath.__name__),"===============================")
            #output("==================================================================================")
            acceptors[c]={}
            proposers[c]={}
            learners[c]={}
            rVals=[0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
            #rVals=[0.0,0.1]
            for rVary in rVals:
                results[c][rVary]={"execTime":0,"cpuTime":0,"n":n}
                for run in range(n):
                    acceptors[c][run]=[]
                    proposers[c][run]=[]
                    learners[c][run]=[]
                    #output("**********************************************************************************")
                    #output("******************************",str(codePath.__name__)," Run: ",run+1,"************************************")
                    #output("**********************************************************************************")
                    startTime=time.time()
                    startCPUTime=time.process_time()

                    acceptors[c][run] = new(codePath.Acceptor, num= a)
                    proposers[c][run] = new(codePath.Proposer, (acceptors[c][run],tp,w,rVary,d), num= p)
                    learners[c][run] = new(codePath.Learner, (acceptors[c][run],tl,rVary,d), num= l)

                    for p in acceptors[c][run]: setup(p, (learners[c][run],rVary,d))


                    start(acceptors[c][run] | proposers[c][run] | learners[c][run])


                    await(each(learner in learners[c][run], has=received(('Learned', learner), from_=learner)))
                    send( ('Done',), to= (acceptors[c][run]  | proposers[c][run])  )
                    results[c][rVary]["execTime"]+= (time.time() - startTime)
                    results[c][rVary]["cpuTime"]+= (time.process_time() - startCPUTime)
        print("results",results)



    def run():
        runPerformanceTests()               #Performance Test
        output('terminating')
        send(('done', self), to= parent())
        output("Sending done to parent")
        await(received(('done'), from_=parent()))


def main():
    p = int(sys.argv[1]) if len(sys.argv) > 1 else 10           # num of proposers
    a = int(sys.argv[2]) if len(sys.argv) > 2 else 10           # num of acceptors
    l = int(sys.argv[3]) if len(sys.argv) > 3 else 10           # num of learners
    n = int(sys.argv[4]) if len(sys.argv) > 4 else 1            # num of runs
    r = float(sys.argv[5]) if len(sys.argv) > 5 else 0.0            # message loss rate
    d = int(sys.argv[6]) if len(sys.argv) > 6 else 1            # message delay
    w = int(sys.argv[7]) if len(sys.argv) > 7 else 1            # wait time
    tp = int(sys.argv[8]) if len(sys.argv) > 8 else 1           # timeout by proposers
    tl = int(sys.argv[9]) if len(sys.argv) > 9 else 1           # timeout by learners
    driver = new(Driver, num=1)
    setup(driver,(p,a,l,n,r,d,w,tp,tl))
    start(driver)
    await(each(e in driver, has=received(('done', e))))

    send(('done'), to=driver)