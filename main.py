# -*- generated by 1.1.0b12 -*-
import da
PatternExpr_598 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern601_')])
PatternExpr_604 = da.pat.BoundPattern('_BoundPattern605_')
PatternExpr_881 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern884_')])
PatternExpr_887 = da.pat.BoundPattern('_BoundPattern888_')
PatternExpr_1164 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern1167_')])
PatternExpr_1170 = da.pat.BoundPattern('_BoundPattern1171_')
PatternExpr_1447 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern1450_')])
PatternExpr_1453 = da.pat.BoundPattern('_BoundPattern1454_')
PatternExpr_1735 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern1738_'), da.pat.BoundPattern('_BoundPattern1740_')])
PatternExpr_1743 = da.pat.BoundPattern('_BoundPattern1744_')
PatternExpr_1765 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.FreePattern('b'), da.pat.ConstantPattern(True)])
PatternExpr_2054 = da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern2057_')])
PatternExpr_2060 = da.pat.BoundPattern('_BoundPattern2061_')
PatternExpr_2145 = da.pat.ConstantPattern('done')
PatternExpr_2149 = da.pat.BoundPattern('_BoundPattern2151_')
PatternExpr_2152 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2158_')]), da.pat.ConstantPattern('done')])
PatternExpr_606 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern612_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern616_')])])
PatternExpr_889 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern895_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern899_')])])
PatternExpr_1172 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1178_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern1182_')])])
PatternExpr_1455 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1461_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern1465_')])])
PatternExpr_1745 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1751_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern1755_'), da.pat.BoundPattern('_BoundPattern1756_')])])
PatternExpr_2062 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2068_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Learned'), da.pat.BoundPattern('_BoundPattern2072_')])])
PatternExpr_2343 = da.pat.TuplePattern([da.pat.ConstantPattern('done'), da.pat.BoundPattern('_BoundPattern2346_')])
PatternExpr_2349 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done'), da.pat.BoundPattern('_BoundPattern2359_')])])
_config_object = {}
import sys
import random
import time
import orig3
import preemption3
codePaths = [orig3]

class Driver(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._DriverReceivedEvent_0 = []
        self._DriverReceivedEvent_1 = []
        self._DriverReceivedEvent_2 = []
        self._DriverReceivedEvent_3 = []
        self._DriverReceivedEvent_4 = []
        self._DriverReceivedEvent_5 = []
        self._DriverReceivedEvent_6 = []
        self._DriverReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_0', PatternExpr_598, sources=[PatternExpr_604], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_1', PatternExpr_881, sources=[PatternExpr_887], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_2', PatternExpr_1164, sources=[PatternExpr_1170], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_3', PatternExpr_1447, sources=[PatternExpr_1453], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_4', PatternExpr_1735, sources=[PatternExpr_1743], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_5', PatternExpr_1765, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_6', PatternExpr_2054, sources=[PatternExpr_2060], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_DriverReceivedEvent_7', PatternExpr_2145, sources=[PatternExpr_2149], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, p, a, l, n, r, d, w, tp, tl, **rest_2364):
        super().setup(p=p, a=a, l=l, n=n, r=r, d=d, w=w, tp=tp, tl=tl, **rest_2364)
        self._state.p = p
        self._state.a = a
        self._state.l = l
        self._state.n = n
        self._state.r = r
        self._state.d = d
        self._state.w = w
        self._state.tp = tp
        self._state.tl = tl
        self._state.results = {}

    def run(self):
        self.runPerformanceTestsVaryingR()
        self.output('terminating')
        self.send(('done', self._id), to=self.parent())
        self.output('Sending done to parent')
        super()._label('_st_label_2142', block=False)
        _st_label_2142 = 0
        while (_st_label_2142 == 0):
            _st_label_2142 += 1
            if PatternExpr_2152.match_iter(self._DriverReceivedEvent_7, _BoundPattern2158_=self.parent(), SELF_ID=self._id):
                _st_label_2142 += 1
            else:
                super()._label('_st_label_2142', block=True)
                _st_label_2142 -= 1

    def formatResults(self, results, varyingFunc):
        self.output('************************************************************************************')
        self.output('********************************Average CPU Time************************************')
        self.output('************************************************************************************')
        self.output('{:<10} | {:<20} | {:<10} '.format(varyingFunc, 'orig3.da', 'preemption3.da'))
        for i in results['orig3']:
            self.output('{:<10} | {:<20} | {:<10} '.format(i, (round((results['orig3'][i]['cpuTime'] / results['orig3'][i]['n']), 4) if (results['orig3'][i]['n'] > 0) else 'Failed'), (round((results['preemption3'][i]['cpuTime'] / results['preemption3'][i]['n']), 4) if (results['preemption3'][i]['n'] > 0) else 'Failed')))
        self.output('\n')
        self.output('************************************************************************************')
        self.output('********************************Average Elapsed Time********************************')
        self.output('************************************************************************************')
        self.output('{:<10} | {:<20} | {:<10} '.format(varyingFunc, 'orig3.da', 'preemption3.da'))
        for i in results['orig3']:
            self.output('{:<10} | {:<20} | {:<10} '.format(i, (round((results['orig3'][i]['execTime'] / results['orig3'][i]['n']), 4) if (results['orig3'][i]['n'] > 0) else 'Failed'), (round((results['preemption3'][i]['execTime'] / results['preemption3'][i]['n']), 4) if (results['preemption3'][i]['n'] > 0) else 'Failed')))

    def runPerformanceTestsVaryingTL(self):
        acceptors = {}
        proposers = {}
        learners = {}
        for codePath in codePaths:
            c = str(codePath.__name__)
            self._state.results[c] = {}
            acceptors[c] = {}
            proposers[c] = {}
            learners[c] = {}
            tlVals = [1, 3, 5, 7, 10]
            for tlVary in tlVals:
                self._state.results[c][tlVary] = {'execTime': 0, 'cpuTime': 0, 'n': self._state.n}
                for run in range(self._state.n):
                    acceptors[c][run] = []
                    proposers[c][run] = []
                    learners[c][run] = []
                    startTime = time.time()
                    startCPUTime = time.process_time()
                    acceptors[c][run] = self.new(codePath.Acceptor, num=self._state.a)
                    proposers[c][run] = self.new(codePath.Proposer, (acceptors[c][run], self._state.tp, self._state.w, self._state.r, self._state.d), num=self._state.p)
                    learners[c][run] = self.new(codePath.Learner, (acceptors[c][run], tlVary, self._state.r, self._state.d), num=self._state.l)
                    for self._state.p in acceptors[c][run]:
                        self._setup(self._state.p, (learners[c][run], self._state.r, self._state.d))
                    self._start(((acceptors[c][run] | proposers[c][run]) | learners[c][run]))
                    super()._label('_st_label_585', block=False)
                    learner = None

                    def UniversalOpExpr_586():
                        nonlocal learner
                        for learner in learners[c][run]:
                            if (not PatternExpr_606.match_iter(self._DriverReceivedEvent_0, _BoundPattern612_=learner, _BoundPattern616_=learner, SELF_ID=self._id)):
                                return False
                        return True
                    _st_label_585 = 0
                    while (_st_label_585 == 0):
                        _st_label_585 += 1
                        if UniversalOpExpr_586():
                            _st_label_585 += 1
                        else:
                            super()._label('_st_label_585', block=True)
                            _st_label_585 -= 1
                    else:
                        if (_st_label_585 != 2):
                            continue
                    if (_st_label_585 != 2):
                        break
                    self.send(('Done',), to=(acceptors[c][run] | proposers[c][run]))
                    self._state.results[c][tlVary]['execTime'] += (time.time() - startTime)
                    self._state.results[c][tlVary]['cpuTime'] += (time.process_time() - startCPUTime)
        print('tlVary', self._state.results)
        self.formatResults(self._state.results, 'Varying tl')

    def runPerformanceTestsVaryingTP(self):
        acceptors = {}
        proposers = {}
        learners = {}
        for codePath in codePaths:
            c = str(codePath.__name__)
            self._state.results[c] = {}
            acceptors[c] = {}
            proposers[c] = {}
            learners[c] = {}
            tpVals = [1, 3, 5, 7, 10]
            for tpVary in tpVals:
                self._state.results[c][tpVary] = {'execTime': 0, 'cpuTime': 0, 'n': self._state.n}
                for run in range(self._state.n):
                    acceptors[c][run] = []
                    proposers[c][run] = []
                    learners[c][run] = []
                    startTime = time.time()
                    startCPUTime = time.process_time()
                    acceptors[c][run] = self.new(codePath.Acceptor, num=self._state.a)
                    proposers[c][run] = self.new(codePath.Proposer, (acceptors[c][run], tpVary, self._state.w, self._state.r, self._state.d), num=self._state.p)
                    learners[c][run] = self.new(codePath.Learner, (acceptors[c][run], self._state.tl, self._state.r, self._state.d), num=self._state.l)
                    for self._state.p in acceptors[c][run]:
                        self._setup(self._state.p, (learners[c][run], self._state.r, self._state.d))
                    self._start(((acceptors[c][run] | proposers[c][run]) | learners[c][run]))
                    super()._label('_st_label_868', block=False)
                    learner = None

                    def UniversalOpExpr_869():
                        nonlocal learner
                        for learner in learners[c][run]:
                            if (not PatternExpr_889.match_iter(self._DriverReceivedEvent_1, _BoundPattern895_=learner, _BoundPattern899_=learner, SELF_ID=self._id)):
                                return False
                        return True
                    _st_label_868 = 0
                    while (_st_label_868 == 0):
                        _st_label_868 += 1
                        if UniversalOpExpr_869():
                            _st_label_868 += 1
                        else:
                            super()._label('_st_label_868', block=True)
                            _st_label_868 -= 1
                    else:
                        if (_st_label_868 != 2):
                            continue
                    if (_st_label_868 != 2):
                        break
                    self.send(('Done',), to=(acceptors[c][run] | proposers[c][run]))
                    self._state.results[c][tpVary]['execTime'] += (time.time() - startTime)
                    self._state.results[c][tpVary]['cpuTime'] += (time.process_time() - startCPUTime)
        print('tpVary', self._state.results)
        self.formatResults(self._state.results, 'Varying tp')

    def runPerformanceTestsVaryingD(self):
        acceptors = {}
        proposers = {}
        learners = {}
        for codePath in codePaths:
            c = str(codePath.__name__)
            self._state.results[c] = {}
            acceptors[c] = {}
            proposers[c] = {}
            learners[c] = {}
            dVals = [1, 3, 5, 7, 10]
            for dVary in dVals:
                self._state.results[c][dVary] = {'execTime': 0, 'cpuTime': 0, 'n': self._state.n}
                for run in range(self._state.n):
                    acceptors[c][run] = []
                    proposers[c][run] = []
                    learners[c][run] = []
                    startTime = time.time()
                    startCPUTime = time.process_time()
                    acceptors[c][run] = self.new(codePath.Acceptor, num=self._state.a)
                    proposers[c][run] = self.new(codePath.Proposer, (acceptors[c][run], self._state.tp, self._state.w, self._state.r, dVary), num=self._state.p)
                    learners[c][run] = self.new(codePath.Learner, (acceptors[c][run], self._state.tl, self._state.r, dVary), num=self._state.l)
                    for self._state.p in acceptors[c][run]:
                        self._setup(self._state.p, (learners[c][run], self._state.r, dVary))
                    self._start(((acceptors[c][run] | proposers[c][run]) | learners[c][run]))
                    super()._label('_st_label_1151', block=False)
                    learner = None

                    def UniversalOpExpr_1152():
                        nonlocal learner
                        for learner in learners[c][run]:
                            if (not PatternExpr_1172.match_iter(self._DriverReceivedEvent_2, _BoundPattern1178_=learner, _BoundPattern1182_=learner, SELF_ID=self._id)):
                                return False
                        return True
                    _st_label_1151 = 0
                    while (_st_label_1151 == 0):
                        _st_label_1151 += 1
                        if UniversalOpExpr_1152():
                            _st_label_1151 += 1
                        else:
                            super()._label('_st_label_1151', block=True)
                            _st_label_1151 -= 1
                    else:
                        if (_st_label_1151 != 2):
                            continue
                    if (_st_label_1151 != 2):
                        break
                    self.send(('Done',), to=(acceptors[c][run] | proposers[c][run]))
                    self._state.results[c][dVary]['execTime'] += (time.time() - startTime)
                    self._state.results[c][dVary]['cpuTime'] += (time.process_time() - startCPUTime)
        print('wVary', self._state.results)
        self.formatResults(self._state.results, 'Varying d')

    def runPerformanceTestsVaryingW(self):
        acceptors = {}
        proposers = {}
        learners = {}
        for codePath in codePaths:
            c = str(codePath.__name__)
            self._state.results[c] = {}
            acceptors[c] = {}
            proposers[c] = {}
            learners[c] = {}
            wVals = [1, 3, 5, 7, 10]
            for wVary in wVals:
                self._state.results[c][wVary] = {'execTime': 0, 'cpuTime': 0, 'n': self._state.n}
                for run in range(self._state.n):
                    acceptors[c][run] = []
                    proposers[c][run] = []
                    learners[c][run] = []
                    startTime = time.time()
                    startCPUTime = time.process_time()
                    acceptors[c][run] = self.new(codePath.Acceptor, num=self._state.a)
                    proposers[c][run] = self.new(codePath.Proposer, (acceptors[c][run], self._state.tp, wVary, self._state.r, self._state.d), num=self._state.p)
                    learners[c][run] = self.new(codePath.Learner, (acceptors[c][run], self._state.tl, self._state.r, self._state.d), num=self._state.l)
                    for self._state.p in acceptors[c][run]:
                        self._setup(self._state.p, (learners[c][run], self._state.r, self._state.d))
                    self._start(((acceptors[c][run] | proposers[c][run]) | learners[c][run]))
                    super()._label('_st_label_1434', block=False)
                    learner = None

                    def UniversalOpExpr_1435():
                        nonlocal learner
                        for learner in learners[c][run]:
                            if (not PatternExpr_1455.match_iter(self._DriverReceivedEvent_3, _BoundPattern1461_=learner, _BoundPattern1465_=learner, SELF_ID=self._id)):
                                return False
                        return True
                    _st_label_1434 = 0
                    while (_st_label_1434 == 0):
                        _st_label_1434 += 1
                        if UniversalOpExpr_1435():
                            _st_label_1434 += 1
                        else:
                            super()._label('_st_label_1434', block=True)
                            _st_label_1434 -= 1
                    else:
                        if (_st_label_1434 != 2):
                            continue
                    if (_st_label_1434 != 2):
                        break
                    self.send(('Done',), to=(acceptors[c][run] | proposers[c][run]))
                    self._state.results[c][wVary]['execTime'] += (time.time() - startTime)
                    self._state.results[c][wVary]['cpuTime'] += (time.process_time() - startCPUTime)
        print('wVary', self._state.results)
        self.formatResults(self._state.results, 'Varying w')

    def runPerformanceTestsVaryingR(self):
        acceptors = {}
        proposers = {}
        learners = {}
        for codePath in codePaths:
            c = str(codePath.__name__)
            self._state.results[c] = {}
            acceptors[c] = {}
            proposers[c] = {}
            learners[c] = {}
            rVals = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]
            for rVary in rVals:
                self._state.results[c][rVary] = {'execTime': 0, 'cpuTime': 0, 'n': self._state.n}
                for run in range(self._state.n):
                    acceptors[c][run] = []
                    proposers[c][run] = []
                    learners[c][run] = []
                    startTime = time.time()
                    startCPUTime = time.process_time()
                    acceptors[c][run] = self.new(codePath.Acceptor, num=self._state.a)
                    proposers[c][run] = self.new(codePath.Proposer, (acceptors[c][run], self._state.tp, self._state.w, rVary, self._state.d), num=self._state.p)
                    learners[c][run] = self.new(codePath.Learner, (acceptors[c][run], self._state.tl, rVary, self._state.d), num=self._state.l)
                    for self._state.p in acceptors[c][run]:
                        self._setup(self._state.p, (learners[c][run], rVary, self._state.d))
                    self._start(((acceptors[c][run] | proposers[c][run]) | learners[c][run]))
                    print('here')
                    super()._label('_st_label_1722', block=False)
                    learner = None

                    def UniversalOpExpr_1723():
                        nonlocal learner
                        for learner in learners[c][run]:
                            if (not PatternExpr_1745.match_iter(self._DriverReceivedEvent_4, _BoundPattern1751_=learner, _BoundPattern1755_=learner, _BoundPattern1756_=_, SELF_ID=self._id)):
                                return False
                        return True
                    _st_label_1722 = 0
                    while (_st_label_1722 == 0):
                        _st_label_1722 += 1
                        if UniversalOpExpr_1723():
                            _st_label_1722 += 1
                        else:
                            super()._label('_st_label_1722', block=True)
                            _st_label_1722 -= 1
                    else:
                        if (_st_label_1722 != 2):
                            continue
                    if (_st_label_1722 != 2):
                        break
                    print('there')
                    hasLearnedSet = {self._state.a for (_, _, (_ConstantPattern1782_, b, _ConstantPattern1785_)) in self._DriverReceivedEvent_5 if (_ConstantPattern1782_ == 'Learned') if (_ConstantPattern1785_ == True)}
                    print(hasLearnedSet)
                    self.send(('Done',), to=(acceptors[c][run] | proposers[c][run]))
                    self._state.results[c][rVary]['execTime'] += (time.time() - startTime)
                    self._state.results[c][rVary]['cpuTime'] += (time.process_time() - startCPUTime)
        print('results r varying: ', self._state.results)
        self.formatResults(self._state.results, 'Varying r')

    def runPerformanceTests(self):
        acceptors = {}
        proposers = {}
        learners = {}
        for codePath in codePaths:
            c = str(codePath.__name__)
            self._state.results[c] = {}
            acceptors[c] = {}
            proposers[c] = {}
            learners[c] = {}
            rVals = [self._state.r]
            for rVary in rVals:
                self._state.results[c][rVary] = {'execTime': 0, 'cpuTime': 0, 'n': self._state.n}
                for run in range(self._state.n):
                    acceptors[c][run] = []
                    proposers[c][run] = []
                    learners[c][run] = []
                    startTime = time.time()
                    startCPUTime = time.process_time()
                    acceptors[c][run] = self.new(codePath.Acceptor, num=self._state.a)
                    proposers[c][run] = self.new(codePath.Proposer, (acceptors[c][run], self._state.tp, self._state.w, rVary, self._state.d), num=self._state.p)
                    learners[c][run] = self.new(codePath.Learner, (acceptors[c][run], self._state.tl, rVary, self._state.d), num=self._state.l)
                    for self._state.p in acceptors[c][run]:
                        self._setup(self._state.p, (learners[c][run], rVary, self._state.d))
                    self._start(((acceptors[c][run] | proposers[c][run]) | learners[c][run]))
                    super()._label('_st_label_2041', block=False)
                    learner = None

                    def UniversalOpExpr_2042():
                        nonlocal learner
                        for learner in learners[c][run]:
                            if (not PatternExpr_2062.match_iter(self._DriverReceivedEvent_6, _BoundPattern2068_=learner, _BoundPattern2072_=learner, SELF_ID=self._id)):
                                return False
                        return True
                    _st_label_2041 = 0
                    while (_st_label_2041 == 0):
                        _st_label_2041 += 1
                        if UniversalOpExpr_2042():
                            _st_label_2041 += 1
                        else:
                            super()._label('_st_label_2041', block=True)
                            _st_label_2041 -= 1
                    else:
                        if (_st_label_2041 != 2):
                            continue
                    if (_st_label_2041 != 2):
                        break
                    self.send(('Done',), to=(acceptors[c][run] | proposers[c][run]))
                    self._state.results[c][rVary]['execTime'] += (time.time() - startTime)
                    self._state.results[c][rVary]['cpuTime'] += (time.process_time() - startCPUTime)
        print('results r varying: ', self._state.results)
        self.formatResults(self._state.results, 'Fixed Input')

class Node_(da.NodeProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._Node_ReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_2343, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        p = (int(sys.argv[1]) if (len(sys.argv) > 1) else 10)
        a = (int(sys.argv[2]) if (len(sys.argv) > 2) else 10)
        l = (int(sys.argv[3]) if (len(sys.argv) > 3) else 10)
        n = (int(sys.argv[4]) if (len(sys.argv) > 4) else 1)
        r = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0.0)
        d = (int(sys.argv[6]) if (len(sys.argv) > 6) else 1)
        w = (int(sys.argv[7]) if (len(sys.argv) > 7) else 1)
        tp = (int(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        tl = (int(sys.argv[9]) if (len(sys.argv) > 9) else 1)
        driver = self.new(Driver, num=1)
        self._setup(driver, (p, a, l, n, r, d, w, tp, tl))
        self._start(driver)
        super()._label('_st_label_2334', block=False)
        e = None

        def UniversalOpExpr_2335():
            nonlocal e
            for e in driver:
                if (not PatternExpr_2349.match_iter(self._Node_ReceivedEvent_0, _BoundPattern2359_=e)):
                    return False
            return True
        _st_label_2334 = 0
        while (_st_label_2334 == 0):
            _st_label_2334 += 1
            if UniversalOpExpr_2335():
                _st_label_2334 += 1
            else:
                super()._label('_st_label_2334', block=True)
                _st_label_2334 -= 1
        self.send('done', to=driver)
